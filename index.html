<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Show Cell Boundaries 3D</title>
  <style>body { margin: 0; overflow: hidden; }</style>
  <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
  </script>
</head>
<body>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 10000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableRotate = true;
controls.enablePan = true;
controls.zoomSpeed = 1.2;

// Lights
scene.add(new THREE.DirectionalLight(0xffffff, 1).position.set(5,10,7.5));
scene.add(new THREE.AmbientLight(0x404040));

// Dimensions
const IMAGE_WIDTH = 5130;
const IMAGE_HEIGHT = 2000;
const colorPalette = [0xff5555,0x55ff55,0x5555ff,0xffff55,0xff55ff,0x55ffff,0xffffff];

/**
 * Build a ring mesh for each plane boundary.
 * No cross-plane facesâ€”just closed loops per slice.
 */
function createMeshFromPlanes(planes, color) {
  const planeNums = Object.keys(planes).map(n=>+n).sort((a,b)=>a-b);
  const xOff = IMAGE_WIDTH/2;
  const yOff = IMAGE_HEIGHT/2;
  const minZ = Math.min(...planeNums);
  const maxZ = Math.max(...planeNums);
  const midZ = (minZ + maxZ)/2;

  const group = new THREE.Group();
  const mat = new THREE.LineBasicMaterial({ color });

  planeNums.forEach(p => {
    const coords = planes[p];
    const pts = new Float32Array(coords.length * 3);
    coords.forEach(([x,y], i) => {
      pts[i*3]   = x - xOff;
      pts[i*3+1] = yOff - y;
      pts[i*3+2] = p - midZ;
    });
    // geometry for loop
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(pts, 3));
    // close the loop by repeating first point
    geom.setDrawRange(0, coords.length + 1);
    const lineLoop = new THREE.LineLoop(geom, mat);
    group.add(lineLoop);
  });

  return group;
}

// Load JSON and render
fetch('cell_boundaries.json')
  .then(r => r.json())
  .then(({ cell_boundaries }) => {
    const master = new THREE.Group();
    Object.entries(cell_boundaries).forEach(([label, planes], i) => {
      const color = colorPalette[i % colorPalette.length];
      const cellMesh = createMeshFromPlanes(planes, color);
      master.add(cellMesh);
    });
    scene.add(master);

    // center camera on data
    const box = new THREE.Box3().setFromObject(master);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);

    camera.position.copy(center.clone().add(new THREE.Vector3(0,0,maxDim*1.2)));
    controls.target.copy(center);
    controls.update();
  })
  .catch(e => console.error('Load error', e));

// Responsive
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Animate
(function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
})();
</script>
</body>
</html>
