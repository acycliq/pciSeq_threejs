<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Front and Back Different Textures</title>
  <style>body { margin: 0; }</style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
      }
    }
  </script>
</head>
<body>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableRotate = true;
controls.enablePan = true;
controls.zoomSpeed = 1.2;

// Light
const light = new THREE.DirectionalLight(0xffffff);
light.position.set(5, 10, 7.5);
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff));

// Textures
const textureLoader = new THREE.TextureLoader();
const frontTexture = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg'); // Front texture
const backTexture = textureLoader.load('https://threejs.org/examples/textures/uv_grid_opengl.jpg'); // Back texture

// Materials
const frontMaterial = new THREE.MeshStandardMaterial({
  map: frontTexture,
  side: THREE.FrontSide,
  metalness: 0.2,
  roughness: 0.7
});

const backMaterial = new THREE.MeshStandardMaterial({
  map: backTexture,
  side: THREE.BackSide,
  metalness: 0.2,
  roughness: 0.7
});

// Planes
const planes = [
  { z: 0, points: [ [1,0], [0.7,0.7], [0,1], [-0.7,0.7], [-1,0], [-0.7,-0.7], [0,-1], [0.7,-0.7] ] },
  { z: 1, points: [ [0.5,0], [0.35,0.35], [0,0.5], [-0.35,0.35], [-0.5,0], [-0.35,-0.35], [0,-0.5], [0.35,-0.35] ] }
];

const pointsPerPlane = planes[0].points.length;
const vertices = [];
const uvs = [];
const indices = [];

for (let p of planes) {
  for (let [x, y] of p.points) {
    vertices.push(x, y, p.z);
    uvs.push((x + 1) / 2, (y + 1) / 2);
  }
}

for (let i = 0; i < pointsPerPlane; i++) {
  const next = (i + 1) % pointsPerPlane;

  const lower = i;
  const lowerNext = next;
  const upper = i + pointsPerPlane;
  const upperNext = next + pointsPerPlane;

  // front face
  indices.push(lower, lowerNext, upper);
  indices.push(lowerNext, upperNext, upper);

  // back face (reverse order for correct normals)
  indices.push(upper, upperNext, lowerNext);
  indices.push(upper, lowerNext, lower);
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
geometry.setIndex(indices);

// Important: split into groups
geometry.clearGroups();
const totalFrontFaces = pointsPerPlane * 2; // 2 triangles per quad for front
geometry.addGroup(0, totalFrontFaces * 3, 0); // 0 = frontMaterial
geometry.addGroup(totalFrontFaces * 3, totalFrontFaces * 3, 1); // 1 = backMaterial

// Create mesh
const mesh = new THREE.Mesh(geometry, [frontMaterial, backMaterial]);
scene.add(mesh);

camera.position.set(3, 3, 10);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
