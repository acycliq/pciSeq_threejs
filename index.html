<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Show Cell Boundaries 3D</title>
  <style>body { margin: 0; overflow: hidden; }</style>
  <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
  </script>
</head>
<body>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 10000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableRotate = true;
controls.enablePan = true;
controls.zoomSpeed = 1.2;

// Lights
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(5, 10, 7.5);
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0x404040));

// Dimensions
const IMAGE_WIDTH = 5130;
const IMAGE_HEIGHT = 2000;
const colorPalette = [0xff5555,0x55ff55,0x5555ff,0xffff55,0xff55ff,0x55ffff,0xffffff];

/**
 * Build a ring mesh for each plane boundary.
 * No cross-plane facesâ€”just closed loops per slice.
 */
function createMeshFromPlanes(planes, color) {
  const planeNums = Object.keys(planes).map(n => +n).sort((a, b) => a - b);
  const xOff = IMAGE_WIDTH / 2;
  const yOff = IMAGE_HEIGHT / 2;
  const minZ = planeNums[0];
  const maxZ = planeNums[planeNums.length - 1];
  const midZ = (minZ + maxZ) / 2;

  // Angularly sort each plane's boundary points
  const perPlaneCoords = planeNums.map(p => {
    const raw = planes[p].map(([x, y]) => [x - xOff, yOff - y]);
    const centroid = raw.reduce((c, [x, y]) => [c[0] + x, c[1] + y], [0, 0])
                     .map(sum => sum / raw.length);
    return raw
      .map(([x, y]) => ({ x, y, angle: Math.atan2(y - centroid[1], x - centroid[0]) }))
      .sort((a, b) => a.angle - b.angle)
      .map(({ x, y }) => [x, y]);
  });

  // Compute vertex offsets for each plane
  const offsets = [0];
  perPlaneCoords.forEach((pts, i) => {
    if (i > 0) offsets.push(offsets[i - 1] + perPlaneCoords[i - 1].length);
  });

  // Build vertex buffer
  const vertices = [];
  perPlaneCoords.forEach((pts, i) => {
    const z = planeNums[i] - midZ;
    pts.forEach(([x, y]) => {
      vertices.push(x, y, z);
    });
  });

  // Build indices only between adjacent planes, matching min counts
  const indices = [];
  for (let i = 0; i < perPlaneCoords.length - 1; i++) {
    const ptsA = perPlaneCoords[i];
    const ptsB = perPlaneCoords[i + 1];
    const len = Math.min(ptsA.length, ptsB.length);
    const offA = offsets[i];
    const offB = offsets[i + 1];
    for (let j = 0; j < len; j++) {
      const next = (j + 1) % len;
      const a = offA + j;
      const b = offA + next;
      const c = offB + j;
      const d = offB + next;
      indices.push(a, b, c);
      indices.push(b, d, c);
    }
  }

  // Create geometry
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();

  // Material
  const material = new THREE.MeshStandardMaterial({
    color,
    metalness: 0.1,
    roughness: 0.8,
    side: THREE.DoubleSide
  });
  return new THREE.Mesh(geometry, material);
}

// Load JSON and render
fetch('cell_boundaries.json')
  .then(r => r.json())
  .then(({ cell_boundaries }) => {
    const group = new THREE.Group();
    Object.entries(cell_boundaries).forEach(([label, planes], i) => {
      const mesh = createMeshFromPlanes(planes, colorPalette[i % colorPalette.length]);
      group.add(mesh);
    });
    scene.add(group);

    // center camera on data
    const box = new THREE.Box3().setFromObject(group);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    camera.position.copy(center.clone().add(new THREE.Vector3(0, 0, maxDim * 1.2)));
    controls.target.copy(center);
    controls.update();
  })
  .catch(e => console.error('Load error', e));

// Responsive
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Animate
(function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
})();
</script>
</body>
</html>
