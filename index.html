<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Show Cell Boundaries 3D</title>
  <style>body { margin: 0; }</style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
      }
    }
  </script>
</head>
<body>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableRotate = true;
controls.enablePan = true;
controls.zoomSpeed = 1.2;

// Lights
const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);
scene.add(new THREE.AmbientLight(0x404040));

// Color palette for labels
const colorPalette = [
  0xff5555, 0x55ff55, 0x5555ff,
  0xffff55, 0xff55ff, 0x55ffff,
  0xffffff
];

/**
 * Build a 3D mesh from a map of planeNumber -> [ [x,y], ... ]
 * @param {Object<string, Array<[number, number]>>} planes
 * @param {number} color
 * @returns {THREE.Mesh}
 */
function createMeshFromPlanes(planes, color) {
  const pointsPerPlane = Object.values(planes)[0].length;
  const planeNumbers = Object.keys(planes)
    .map(key => parseInt(key, 10))
    .sort((a, b) => a - b);

  const vertices = [];
  const indices = [];

  // Build vertices
  planeNumbers.forEach(planeNo => {
    const coords = planes[planeNo];
    coords.forEach(([x, y]) => {
      vertices.push(x, y, planeNo);
    });
  });

  // Build indices to connect quads across layers
  for (let i = 0; i < planeNumbers.length - 1; i++) {
    for (let j = 0; j < pointsPerPlane; j++) {
      const next = (j + 1) % pointsPerPlane;
      const lower     = i      * pointsPerPlane + j;
      const lowerNext = i      * pointsPerPlane + next;
      const upper     = (i + 1) * pointsPerPlane + j;
      const upperNext = (i + 1) * pointsPerPlane + next;

      indices.push(lower, lowerNext, upper);
      indices.push(lowerNext, upperNext, upper);
    }
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute(
    'position',
    new THREE.Float32BufferAttribute(vertices, 3)
  );
  geometry.setIndex(indices);
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({
    color,
    metalness: 0.1,
    roughness: 0.8,
    side: THREE.DoubleSide
  });

  return new THREE.Mesh(geometry, material);
}

// Load and visualize JSON data
fetch('cell_boundaries.json')
  .then(response => response.json())
  .then(({ cell_boundaries: allBoundaries }) => {
    Object.entries(allBoundaries).forEach(([label, planes], index) => {
      const color = colorPalette[index % colorPalette.length];
      const mesh = createMeshFromPlanes(planes, color);
      scene.add(mesh);
    });
  })
  .catch(err => console.error('Failed to load JSON', err));

// Camera initial position
camera.position.set(0, 0, 50);
camera.lookAt(0, 0, 0);

// Render loop
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
